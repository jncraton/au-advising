#!/usr/bin/env python3
from pathlib import Path
import sys
import shutil
import argparse


def find_skill_md(start: Path) -> Path | None:
    for p in (start, *start.iterdir()):
        if not isinstance(p, Path):
            p = Path(p)
        candidate = p / 'SKILL.md' if p.is_dir() else None
        if candidate and candidate.exists():
            return candidate
    explicit = start / 'SKILL.md'
    return explicit if explicit.exists() else None


def find_references_dir(start: Path) -> Path | None:
    refs = start / 'references'
    if refs.exists() and refs.is_dir():
        return refs
    for d in start.rglob('references'):
        if d.is_dir():
            return d
    return None


def gather_reference_files(refs_dir: Path, min_start_year: int = 2023) -> list[str]:
    tsv_files: list[str] = []
    md_files: list[str] = []
    for p in sorted(refs_dir.rglob('*')):
        if not p.is_file():
            continue
        ext = p.suffix.lower()
        if ext not in ('.md', '.tsv'):
            continue

        # Determine whether this file lives under a year directory like 2022-23
        try:
            rel_within = p.relative_to(refs_dir)
        except Exception:
            rel_within = None

        if rel_within and len(rel_within.parts) >= 1:
            year_dir = rel_within.parts[0]
            # Accept directories matching YYYY-YY and skip those with start year <
            # min_start_year
            if len(year_dir) >= 4 and year_dir[:4].isdigit():
                try:
                    start_year = int(year_dir[:4])
                except Exception:
                    start_year = None
                if start_year is not None and start_year < min_start_year:
                    continue

        try:
            rel = p.relative_to(refs_dir.parent)
        except Exception:
            rel = p
        entry = str(rel).replace('\\', '/')
        if ext == '.tsv':
            tsv_files.append(entry)
        else:
            md_files.append(entry)

    # Ensure TSV files appear first, then markdown files
    return tsv_files + md_files


def replace_list_in_skill(skill_path: Path, entries: list[str], verbose: bool = False, dry_run: bool = False) -> int:
    text = skill_path.read_text(encoding='utf8')
    markers = [
        'You have access to the following',
        'The following reference files are in the skill directory:',
        'The following reference files are in the skill directory',
        'The following reference files are:',
        'The following reference files',
    ]
    idx = -1
    marker = None
    for m in markers:
        idx = text.find(m)
        if idx != -1:
            marker = m
            break
    if idx == -1:
        return 2
    # include the remainder of the line containing the marker so preserve
    # any parenthetical example or punctuation that follows the phrase
    line_end = text.find('\n', idx)
    if line_end == -1:
        head = text
        rest = ''
    else:
        head = text[: line_end + 1]
        rest = text[line_end + 1 :]
    lines = rest.splitlines(keepends=True)
    i = 0
    while i < len(lines) and lines[i].strip() == '':
        i += 1
    if i >= len(lines) or not lines[i].startswith(' '):
        start_line = i
    else:
        start_line = i
    j = start_line
    while j < len(lines) and lines[j].startswith(' '):
        j += 1
    new_block = ''.join('    ' + e + '\n' for e in entries)
    # remove any blank lines that follow the old list so we only insert a single
    # blank line between the new list and the remainder of the file
    k = j
    while k < len(lines) and lines[k].strip() == '':
        k += 1
    tail = ''.join(lines[k:])

    if new_block:
        if tail:
            # leave exactly one blank line after the list
            new_rest = ''.join(lines[:start_line]) + new_block + '\n' + tail
        else:
            # file ends after the list; ensure it ends with a single newline
            if not new_block.endswith('\n'):
                new_block += '\n'
            new_rest = ''.join(lines[:start_line]) + new_block
    else:
        # no entries â€” just join the non-blank remainder
        new_rest = ''.join(lines[:start_line]) + tail
    new_text = head + new_rest
    if new_text == text:
        if verbose:
            print(f'No changes required for {skill_path}')
        return 0
    if dry_run:
        if verbose:
            print(f'Dry run: would update {skill_path} with {len(entries)} entries')
        return 0
    skill_path.write_text(new_text, encoding='utf8')
    if verbose:
        print(f'Updated {skill_path} with {len(entries)} entries')
    return 0


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('--startyear', '-s', type=int, default=2023)
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('--dryrun', action='store_true')
    args = parser.parse_args()

    cwd = Path.cwd()
    skill = find_skill_md(cwd)
    if not skill:
        return 1
    refs = find_references_dir(skill.parent)
    if not refs:
        return 3
    entries = gather_reference_files(refs, args.startyear)
    if args.verbose:
        print(f'Found {len(entries)} reference entries under {refs}')
    return replace_list_in_skill(skill, entries, verbose=args.verbose, dry_run=args.dryrun)


if __name__ == '__main__':
    sys.exit(main())
